---
layout: lesson
root: .
---

在本课中，我们使用一个名为pytest的Python库。

> ## 前提
>
> 基本了解Python变量和函数是必要的先决条件。需要有一些使用shell脚本的经验，*但不是强制性的*。
{: .prereq}

在依赖新的实验设备之前，实验科学家总是要确定其准确性。当科学家观察到它对已知输入信号的响应时，就会校准一个新的探测器。将此校准的结果与_expected_响应进行比较。**实验科学家永远不会使用未经校准的探测器进行实验——那是不科学的。同样，使用未经测试的软件进行模拟和分析也不科学。**

> ## 你测试了什么
>
> **只有通过测试才能知道。** 软件bug隐藏在所有重要的软件中。测试是系统地消除这些错误的过程。在软件测试中，就像在设备校准中一样，将预期结果与观察结果进行比较以确定准确性。
{: .callout}

给定代码的所有测试用例的集合称为**测试套件**。你可以把测试套件想象成一堆任何人都可以运行的预制实验。如果所有的测试都通过了，那么代码至少是部分可信的。如果任何测试失败，那么无论哪种情况失败，都知道代码是不正确的。在本课之后，您将知道当软件的测试没有**覆盖**其声称的功能以及当它的测试没有通过时，不要信任该软件。

> ## 管理期望
>
> 就像科学领域对实验精度有期望一样，它也可能对允许的计算精度有期望。当您评估自己或其他人的软件的可接受性时，这些考虑因素肯定会发挥作用。
{: .callout}

在大多数其他编程工作中，如果代码从根本上是错误的——即使一次是几年——这个错误的影响可能相对较小。可能是某个网站出现故障，或者游戏崩溃，或者由于文字处理器中的错误而浪费了几天的写作时间。另一方面，科学代码控制飞机、武器系统、卫星、农业，最重要的是科学模拟和实验。如果管理计算或物理实验的软件有误，就会导致灾难。

这并不是说科学家垄断了软件测试，只是说除非经过验证，否则软件不能被称为“科学”。

> ## 没有测试的代码......是遗留代码！
>
> 在 *[Working Effectively with Legacy Code][feathers-legacy-code]* 中，Michael Feathers将遗留代码定义为“任何未经测试的代码”。这个定义基于这样一个事实：即在最初创建之后，测试为其他开发人员（以及你健忘的自己，几个月后）提供了关于如何使用每个函数的强大指南。如果没有可运行的测试来提供代码使用示例，即使是全新的程序也是不可持续的。
{: .callout}

测试是计算模拟和分析领域的校准步骤：它让科学家从根本上信任自己的工作，并帮助其他人理解和信任他们的工作。此外，测试可以帮助您永远不会再次修复错误。一旦一个bug被捕获并编写了一个测试，这个特定的bug就再也不会在不被注意的情况下重新进入代码库。因此，无论是出于原则动机还是希望更有效地工作，所有科学家都可以从测试中受益。

[feathers-legacy-code]: http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/
